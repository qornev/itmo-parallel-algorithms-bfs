# CW2. Parallel Breadth-First-Search

## Problem

Нужно реализовать параллельный bfs. От Вас требуется написать последовательную версию алгоритма  (seq) и параллельную версию (par). Протестировать надо на кубическом графе со стороной 500 и источником в (0, 0, 0). (Усреднить по 5 запускам) Сравнить время работы par на 4 процессах и seq на одном процессе - у Вас должно быть раза в 3 быстрее.  (Если будет медленнее, то выставление баллов оставляется на моё усмотрение.) Учтите, что Ваш bfs должен работать на любом графе, если Вам дан его список смежности.

## Solution

Было реализовано два алгоритма bfs:

- Параллельный с помощью OpenCilk -- `src/par_bfs.cpp`;
- Последовательный -- `src/seq_bfs.cpp`.

Скрипты запусков находятся в `Makefile`.

Результаты запусков можно посмотреть в файлах `results/16_gran.txt` и `results/32_gran.txt`. 16 и 32 - коэффициенты, на которые умножается количество воркеров силка, чтобы определить гранулярность. При кф 8 скорость работы параллельного алгоритма не особо быстрее последовательно :( Запуск проводится на кубе со стороной 320, больше не влезает в память

Таблица для кф 32 (ms)

| algorithm | 1st run | 2nd run | 3rd run | 4th run | 5th run | mean | diff |
| --------- | ------- | ------- | ------- | ------- | ------- | ---- | ---- |
| sequential | 14001 | 14221 | 14350 | 14362 | 14459 | 14278.6 | x2.3 |
| parallel | 6300 | 6215 | 6291 | 6233 | 6250 | 6257.8 | x1.0 |

Среднее время параллельного алгоритма ~6257.8 ms, а последовательного -- ~14278.6 ms. Параллельный алгоритм быстрее последовательного в ~2.3 раза.
